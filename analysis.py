# -*- coding: utf-8 -*-
"""Applications of Spatial Omics

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PND2C2RcItYQIKeotR7I8wV4Xa2VIyY4
"""

# data from https://www.10xgenomics.com/datasets/xenium-human-brain-preview-data-1-standard
# Applications of Sptial Omics Intersession 2026
# Suwen's Project
# Assisted by ChatGPT

!pip install scanpy squidpy anndata numpy harmonypy matplotlib

!pip install igraph leidenalg

"""Import Statements"""

import scanpy as sc
import squidpy as sq
import anndata as ad
import numpy as np
import harmonypy as hm
import matplotlib.pyplot as plt

"""Load Data"""

# load data
healthy = sc.read_10x_mtx(
    "healthy",
    var_names="gene_symbols",
    cache=True
)

alz = sc.read_10x_mtx(
    "alzheimers",
    var_names="gene_symbols",
    cache=True
)

healthy.obs["condition"] = "Healthy"
alz.obs["condition"] = "Alzheimers"

print("Data loaded.")

"""Filter Data"""

# quality control
def filter(adata):
    # mark mitochondrial genes
    adata.var["mt"] = adata.var_names.str.startswith("MT-")

    sc.pp.calculate_qc_metrics(
        adata,
        qc_vars=["mt"],
        percent_top=None,
        inplace=True
    )

    print("Number of genes before filtering:", adata.n_vars)
    print("Number of cells before filtering:", adata.n_obs)

    # filter cells with < 20 genes total
    adata = adata[(adata.obs.n_genes_by_counts > 20)]

    # filter genes expressed in fewer than 3 spots
    sc.pp.filter_genes(adata, min_cells=3)

    print("Number of genes after filtering:", adata.n_vars)
    print("Number of cells after filtering:", adata.n_obs, "\n")
    return adata

print("Filtering healthy genes.")
healthy = filter(healthy)
print("Filtering alzheimers genes")
alz = filter(alz)

# visualization
# Make sure QC metrics exist
for a in [healthy, alz]:
    if "pct_counts_mt" not in a.obs:
        a.var["mt"] = a.var_names.str.startswith("MT-")
        sc.pp.calculate_qc_metrics(a, qc_vars=["mt"], inplace=True)

# Combine datasets if you want side-by-side
adata = healthy.concatenate(alz, batch_key="condition", batch_categories=["Healthy", "Alzheimers"])

# Violin plot for QC metrics
qc_metrics = ["n_genes_by_counts", "total_counts", "pct_counts_mt"]

sc.pl.violin(
    adata,
    keys=qc_metrics,
    groupby="condition",   # shows healthy vs AD side by side
    rotation=45,
    jitter=0.4,
    multi_panel=True,      # separate panel per metric
    size=2                 # point size
)

"""Concatenate genes + Normalize"""

# concantenate genes
adata = ad.concat(
    [healthy, alz],
    join="outer",
    label="sample",
    keys=["Healthy", "Alzheimers"],
    fill_value=0
)
adata.obs_names_make_unique()

sc.pp.normalize_total(adata, target_sum=1e4)
sc.pp.log1p(adata)

adata.raw = adata

print("normalized and log-transform data")

sc.pp.highly_variable_genes(
    adata,
    batch_key="sample",
    n_top_genes=3000
)

adata = adata[:, adata.var.highly_variable]

"""Harmonize Data"""

sc.pp.scale(adata, max_value=10)
sc.tl.pca(adata, n_comps=50)

sc.pp.neighbors(
    adata,
    use_rep="X_pca"
)
sc.tl.umap(adata)

sc.tl.leiden(adata, key_added="leiden_pre")

sc.pl.umap(
    adata,
    color=["leiden_pre", "sample"],
    wspace=0.4
)

# harmonization
sc.pp.scale(adata, max_value=10)
sc.tl.pca(adata, n_comps=20)

ho = hm.run_harmony(
    adata.obsm["X_pca"],
    adata.obs,
    vars_use=["sample"],
    theta=11, # Increased theta for more aggressive harmonization
    max_iter_harmony=50
)

adata.obsm["X_pca_harmony"] = ho.Z_corr

print("harmonized")

sc.pp.neighbors(
    adata,
    use_rep="X_pca_harmony"
)

sc.pp.neighbors(
    adata,
    use_rep="X_pca_harmony"
)
sc.tl.umap(adata)

sc.tl.leiden(adata, key_added="leiden_post")

sc.pl.umap(
    adata,
    color=["leiden_post", "sample"],
    wspace=0.4
)

sc.pl.umap(
    adata,
    color=["sample"],
    wspace=0.4
)

sc.pp.neighbors(
    adata,
    n_neighbors=10,
    n_pcs=20, # Reduced n_pcs to match the number of components in X_pca_harmony
    use_rep="X_pca_harmony"
)

sc.tl.leiden(
    adata,
    resolution=0.2, # Changed resolution to 0.2 to reduce the number of clusters
    key_added="leiden_coarse"
)

sc.pl.umap(
    adata,
    color=["leiden_coarse"],
    wspace=0.4
)